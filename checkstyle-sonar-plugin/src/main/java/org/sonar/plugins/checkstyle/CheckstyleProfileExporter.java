////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2017 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 3 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package org.sonar.plugins.checkstyle;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.lang.StringEscapeUtils;
import org.apache.commons.lang.StringUtils;
import org.sonar.api.config.Settings;
import org.sonar.api.profiles.ProfileExporter;
import org.sonar.api.profiles.RulesProfile;
import org.sonar.api.rules.ActiveRule;
import org.sonar.api.rules.RuleParam;

import com.google.common.annotations.VisibleForTesting;

public class CheckstyleProfileExporter extends ProfileExporter {

    public static final String DOCTYPE_DECLARATION =
        "<!DOCTYPE module PUBLIC \"-//Puppy Crawl//DTD Check Configuration 1.2//EN\" "
        + "\"http://www.puppycrawl.com/dtds/configuration_1_2.dtd\">";

    private static final String CLOSE_MODULE = "</module>";

    private final Settings settings;

    public CheckstyleProfileExporter(Settings settings) {
        super(CheckstyleConstants.REPOSITORY_KEY, CheckstyleConstants.PLUGIN_NAME);
        this.settings = settings;
        setSupportedLanguages(CheckstyleConstants.JAVA_KEY);
        setMimeType("application/xml");
    }

    @Override
    public void exportProfile(RulesProfile profile, Writer writer) {
        try {
            final List<ActiveRule> activeRules = profile
                    .getActiveRulesByRepository(CheckstyleConstants.REPOSITORY_KEY);
            if (activeRules != null) {
                final Map<String, List<ActiveRule>> activeRulesByConfigKey =
                        arrangeByConfigKey(activeRules);
                generateXml(writer, activeRulesByConfigKey);
            }
        }
        catch (IOException ex) {
            throw new IllegalStateException("Fail to export the profile " + profile, ex);
        }

    }

    private void generateXml(Writer writer, Map<String, List<ActiveRule>> activeRulesByConfigKey)
            throws IOException {
        appendXmlHeader(writer);
        appendCustomFilters(writer);
        appendCheckerModules(writer, activeRulesByConfigKey);
        appendTreeWalker(writer, activeRulesByConfigKey);
        appendXmlFooter(writer);
    }

    private static void appendXmlHeader(Writer writer) throws IOException {
        writer.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + DOCTYPE_DECLARATION
                + "<!-- Generated by Sonar -->" + "<module name=\"Checker\">");
    }

    private void appendCustomFilters(Writer writer) throws IOException {
        final String filtersXml = settings.getString(CheckstyleConstants.CHECKER_FILTERS_KEY);
        if (StringUtils.isNotBlank(filtersXml)) {
            writer.append(filtersXml);
        }
    }

    private static void appendCheckerModules(Writer writer,
            Map<String, List<ActiveRule>> activeRulesByConfigKey) throws IOException {
        for (Entry<String, List<ActiveRule>> entry : activeRulesByConfigKey.entrySet()) {
            final String configKey = entry.getKey();
            if (!isInTreeWalker(configKey)) {
                final List<ActiveRule> activeRules = entry.getValue();
                for (ActiveRule activeRule : activeRules) {
                    appendModule(writer, activeRule);
                }
            }
        }
    }

    private void appendTreeWalker(Writer writer,
            Map<String, List<ActiveRule>> activeRulesByConfigKey) throws IOException {
        writer.append("<module name=\"TreeWalker\">");
        writer.append("<module name=\"FileContentsHolder\"/> ");
        if (isSuppressWarningsEnabled()) {
            writer.append("<module name=\"SuppressWarningsHolder\"/> ");
        }
        final List<String> ruleSet = new ArrayList<>(activeRulesByConfigKey.keySet());
        Collections.sort(ruleSet);
        for (String configKey : ruleSet) {
            if (isInTreeWalker(configKey)) {
                final List<ActiveRule> activeRules = activeRulesByConfigKey.get(configKey);
                for (ActiveRule activeRule : activeRules) {
                    appendModule(writer, activeRule);
                }
            }
        }
        // append Treewalker filters
        final String filtersXml = settings.getString(CheckstyleConstants.TREEWALKER_FILTERS_KEY);
        if (StringUtils.isNotBlank(filtersXml)) {
            writer.append(filtersXml);
        }
        writer.append(CLOSE_MODULE);
    }

    private boolean isSuppressWarningsEnabled() {
        final String filtersXml = settings.getString(CheckstyleConstants.CHECKER_FILTERS_KEY);
        boolean result = false;
        if (filtersXml != null) {
            result = filtersXml.contains("<module name=\"SuppressWarningsFilter\" />");
        }
        return result;
    }

    private static void appendXmlFooter(Writer writer) throws IOException {
        writer.append(CLOSE_MODULE);
    }

    @VisibleForTesting
    static boolean isInTreeWalker(String configKey) {
        return StringUtils.startsWithIgnoreCase(configKey, "Checker/TreeWalker/");
    }

    private static Map<String, List<ActiveRule>> arrangeByConfigKey(List<ActiveRule> activeRules) {
        final Map<String, List<ActiveRule>> result = new HashMap<>();
        for (ActiveRule activeRule : activeRules) {
            final String key = activeRule.getConfigKey();
            if (result.containsKey(key)) {
                final List<ActiveRule> rules = result.get(key);
                rules.add(activeRule);
            }
            else {
                final List<ActiveRule> rules = new ArrayList<>();
                rules.add(activeRule);
                result.put(key, rules);
            }
        }
        return result;
    }

    private static void appendModule(Writer writer, ActiveRule activeRule) throws IOException {
        final String moduleName = StringUtils.substringAfterLast(activeRule.getConfigKey(), "/");
        writer.append("<module name=\"");
        StringEscapeUtils.escapeXml(writer, moduleName);
        writer.append("\">");
        if (activeRule.getRule().getTemplate() != null) {
            appendModuleProperty(writer, "id", activeRule.getRuleKey());
        }
        appendModuleProperty(writer, "severity",
                CheckstyleSeverityUtils.toSeverity(activeRule.getSeverity()));
        appendRuleParameters(writer, activeRule);
        writer.append(CLOSE_MODULE);
    }

    private static void appendRuleParameters(Writer writer, ActiveRule activeRule)
            throws IOException {
        for (RuleParam ruleParam : activeRule.getRule().getParams()) {
            final String value = activeRule.getParameter(ruleParam.getKey());
            if (StringUtils.isNotBlank(value)) {
                appendModuleProperty(writer, ruleParam.getKey(), value);
            }
        }
    }

    private static void appendModuleProperty(Writer writer, String propertyKey,
            String propertyValue) throws IOException {
        if (StringUtils.isNotBlank(propertyValue)) {
            writer.append("<property name=\"");
            StringEscapeUtils.escapeXml(writer, propertyKey);
            writer.append("\" value=\"");
            StringEscapeUtils.escapeXml(writer, propertyValue);
            writer.append("\"/>");
        }
    }

}
